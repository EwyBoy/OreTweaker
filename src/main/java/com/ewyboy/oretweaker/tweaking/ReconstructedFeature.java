package com.ewyboy.oretweaker.tweaking;

import com.ewyboy.oretweaker.config.Settings;
import com.ewyboy.oretweaker.json.JSONHandler;
import com.ewyboy.oretweaker.json.objects.OreEntry;
import com.ewyboy.oretweaker.json.objects.biome.BiomeFilters;
import com.ewyboy.oretweaker.util.ModLogger;
import net.minecraft.core.Holder;
import net.minecraft.core.Registry;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
import net.minecraft.world.level.levelgen.feature.configurations.OreConfiguration;
import net.minecraft.world.level.levelgen.placement.PlacedFeature;
import net.minecraftforge.registries.ForgeRegistries;

import java.util.*;

public class ReconstructedFeature {

    public static final List<Holder<PlacedFeature>> reconstructedOres = new LinkedList<>();
    private static final Map<Holder<PlacedFeature>, BiomeFilters> biomeFilterMap = new HashMap<>();

    public static void reconstructFeatureFromJSON() {
        List<OreEntry> ores = JSONHandler.oreConfig.getOreConfig();
        for (OreEntry ore : ores) {
            if (isReconstructableObject(ore)) {
                try {
                    for (String replace : ore.getFillers()) {
                        Holder<ConfiguredFeature<OreConfiguration, ?>> configuredFeature = ReconstructedConfiguredFeature.reconstructConfigured(
                                ore,
                                Objects.requireNonNull(ForgeRegistries.BLOCKS.getValue(new ResourceLocation(ore.getOre()))),
                                replace.toLowerCase(),
                                ore.getMinY(),
                                ore.getMaxY(),
                                ore.getSpawnRate(),
                                ore.getMaxVeinSize(),
                                ore.getDiscardChanceOnAirExposure(),
                                false
                        );

                        Holder<PlacedFeature> placedFeature = ReconstructedPlacedFeature.reconstructPlaced(configuredFeature,
                                Objects.requireNonNull(ForgeRegistries.BLOCKS.getValue(new ResourceLocation(ore.getOre()))),
                                replace.toLowerCase(),
                                ore.getMinY(),
                                ore.getMaxY(),
                                ore.getSpawnRate(),
                                ore.getMaxVeinSize(),
                                ore.getDiscardChanceOnAirExposure(),
                                ore.getDistribution(),
                                false
                        );

                        biomeFilterMap.put(placedFeature, ore.getBiomeFilter());
                        reconstructedOres.add(placedFeature);
                    }
                } catch (Exception ignored) {
                    ModLogger.error(ore.getOre() + " can't be reconstructed from JSON..");
                }
            } else {
                ModLogger.error(ore.getOre() + " can't be reconstructed ??");
            }
        }
    }

    private static final List<String> registryNames = new ArrayList<>();

    public static String createUniqueRegistryName(Block block, String filler, int minY, int maxY, float spawnRate, int maxVeinSize, float discardChanceOnAirExposure, String distribution, boolean isDeepSlate, String featureType) {
        String registryName = isDeepSlate ? "deepslate_" : "ore_";

        registryName = registryName + String.format("%s_%s_%s_%s_%s_%s_%s_%s_%s_feature",
                Objects.requireNonNull(Registry.BLOCK.getKey(block).getPath()),
                filler,
                minY,
                maxY,
                spawnRate,
                maxVeinSize,
                discardChanceOnAirExposure,
                distribution,
                featureType
        );

        registryName = makeRegistryNameUnique(registryName);
        ModLogger.debug("Registry Name: " + registryName);
        registryNames.add(registryName);

        return registryName;
    }

    private static String makeRegistryNameUnique(String name) {
        if (registryNames.contains(name)) {
            int i = 1;
            while (registryNames.contains(name + "_" +  i)) {
                i++;
            }
            return name + "_" +  i;
        }
        return name;
    }

    public static boolean hasDeepslateVariant(OreEntry entry) {
        if (Settings.SETTINGS.autoGenerateDeepslateVariants.get()) {
            return ForgeRegistries.BLOCKS.getValue(formatDeepslate(entry)) != null || ForgeRegistries.BLOCKS.getValue(formatDeepslate(entry)) != Blocks.AIR;
        }
        return false;
    }

    public static Block getDeepslateVariant(OreEntry entry) {
        Block deepslate_ore = ForgeRegistries.BLOCKS.getValue(formatDeepslate(entry));
        ModLogger.debug("Deepslate Ore: " + Objects.requireNonNull(deepslate_ore).getName() + " : " + deepslate_ore.getName());

        return deepslate_ore;
    }

    private static ResourceLocation formatDeepslate(OreEntry entry) {
        String[] ore_split = entry.getOre().split(":");
        String domain = ore_split[0];
        String name = ore_split[1];
        name = "deepslate_" + name;
        String newResourceLocation = domain + ":" + name;
        ModLogger.debug("Format Deepslate :: " + newResourceLocation);

        return new ResourceLocation(newResourceLocation);
    }

    private static boolean isReconstructableObject(OreEntry entry) {
        return entry.getFillers() != null && entry.getMinY() != - 1 && entry.getMaxY() != - 1 && entry.getSpawnRate() != - 1 && entry.getMaxVeinSize() != - 1 && entry.getBiomeFilter().getBiomeBlacklist() != null && entry.getBiomeFilter().getBiomeWhitelist() != null;
    }

}
